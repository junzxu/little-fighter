// Generated by CoffeeScript 1.7.1
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  window.Game = (function() {
    function Game() {
      this.buildCharacter = __bind(this.buildCharacter, this);
    }

    Game.prototype.init = function() {
      this.keysDown = {};
      this.players = [];
      this.player_count = 1;
      this.stageInit();
      this.serverInit();
      this.localPlayer = null;
      createjs.Ticker.setFPS(60);
      this.ready = false;
      this.lastKeyPress = new Date();
      return this.addEventHandlers();
    };

    Game.prototype.serverInit = function() {
      this.socket = io.connect("localhost", {
        port: 3000,
        transports: ["websocket"]
      });
      return console.log('\t connected to server');
    };

    Game.prototype.stageInit = function() {
      var bar, canvas;
      console.log('\t stage init...');
      canvas = document.getElementById("gameCanvas");
      bar = document.getElementById("hud");
      this.world = new World(canvas, bar);
      return console.log('\t stage completed');
    };

    Game.prototype.addEventHandlers = function() {
      this.socket.on("connected", this.onConnected.bind(this));
      this.socket.on("joined", this.gameSetup.bind(this));
      this.socket.on("update", this.onUpdate.bind(this));
      this.socket.on("start", this.gameStart.bind(this));
      this.socket.on("remove", this.onRemove.bind(this));
      this.socket.on("new player", this.onNewPlayer.bind(this));
      this.socket.on("player disconnect", this.onPlayerDisconnect.bind(this));
      return createjs.Ticker.addEventListener("tick", this.onTick.bind(this));
    };

    Game.prototype.onUpdate = function(data) {
      var character, magic, object, player, _i, _len, _ref, _ref1, _results;
      _ref = data.objects;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        object = _ref[_i];
        if ((_ref1 = object.type) === "player" || _ref1 === "robot") {
          player = this.world.getPlayer(object.id);
          if (player !== null) {
            player.update(object);
          } else {
            character = this.buildCharacter(object);
            console.log(character);
            this.world.addPlayer(character, this.player_count);
            this.player_count += 1;
          }
        }
        if (object.type === "magic") {
          magic = this.world.getObject(object.id);
          if (magic === null) {
            magic = new Magic(object.id, object.name, object.x, object.y, this.world, object.characterID, object.direction, object.magicSheetInfo);
          } else {
            magic.get().x = object.x;
            magic.get().y = object.y;
          }
        }
        _results.push(this.world.get().sortChildren(this.renderOrder));
      }
      return _results;
    };

    Game.prototype.renderOrder = function(obj1, obj2) {
      if (obj1.y > obj2.y) {
        return 1;
      }
      if (obj1.y < obj2.y) {
        return -1;
      }
      return 0;
    };

    Game.prototype.onRemove = function(data) {
      var target;
      target = this.world.getObject(data.object.id);
      if (target !== null) {
        return this.world.removeObject(target);
      }
    };

    Game.prototype.onConnected = function(data) {
      this.id = data.id;
      this.gameid = data.gameid;
      console.log('client id is ' + this.id);
      return console.log('game id is ' + data.gameid);
    };

    Game.prototype.gameStart = function(data) {
      return console.log("receive game started");
    };

    Game.prototype.gameSetup = function(data) {
      var character;
      console.log('\t player ' + this.id + ' has joined game');
      this.gameid = data.gameid;
      this.world.build(data.world);
      createjs.Ticker.addEventListener("tick", this.world.stage);
      character = this.buildCharacter(data.character);
      console.log(character);
      this.world.addPlayer(character, this.player_count);
      this.player_count += 1;
      this.localPlayer = character;
      createjs.Ticker.addEventListener("tick", (function(evt) {}).bind(this));
      window.addEventListener("keydown", (function(e) {
        return this.keysDown[e.keyCode] = true;
      }).bind(this));
      window.addEventListener("keyup", (function(e) {
        this.keysDown[e.keyCode] = false;
        if (!this.keysDown[Constant.KEYCODE_RIGHT] && !this.keysDown[Constant.KEYCODE_LEFT] && !this.keysDown[Constant.KEYCODE_UP] && !this.keysDown[Constant.KEYCODE_DOWN]) {
          if (this.localPlayer.get().currentAnimation === "run") {
            return this.socket.emit("update", {
              id: this.id,
              action: "keyup"
            });
          }
        }
      }).bind(this));
      return this.localPlayer.get().addEventListener("animationend", ((function(_this) {
        return function(evt) {
          switch (_this.localPlayer.state) {
            case 'die':
              _this.socket.emit("update", {
                id: _this.id,
                action: "animationend"
              });
              break;
            case 'disabled':
              break;
            case 'collided':
              break;
            case 'attack':
              _this.socket.emit("update", {
                id: _this.id,
                action: "animationend"
              });
              return _this.localPlayer.idle();
            case 'hurt':
              _this.socket.emit("update", {
                id: _this.id,
                action: "animationend"
              });
              return _this.localPlayer.idle();
            case 'cast':
              _this.socket.emit("update", {
                id: _this.id,
                action: "animationend"
              });
              return _this.localPlayer.idle();
            default:
              return _this.localPlayer.idle();
          }
        };
      })(this)).bind(this));
    };

    Game.prototype.onNewPlayer = function(data) {
      var player;
      if (!(this.playerExists(data.id))) {
        console.log('Add new player to stage ' + data.id);
        player = this.buildCharacter(data.player);
        this.world.addPlayer(player, this.player_count);
        return this.player_count += 1;
      }
    };

    Game.prototype.onPlayerDisconnect = function(data) {
      if (this.world.playerExists(data.id)) {
        console.log('player:' + data.id + ' leave the game');
        this.world.removePlayer(player);
        return this.player_count -= 1;
      }
    };

    Game.prototype.onTick = function(e) {
      if (this.checkState(this.localPlayer)) {
        if (this.keysDown[Constant.KEYCODE_J]) {
          this.socket.emit("update", {
            id: this.id,
            action: 'attack'
          });
          this.localPlayer.state = "attack";
          return;
        }
        if (this.keysDown[Constant.KEYCODE_K]) {
          this.socket.emit("update", {
            id: this.id,
            action: 'cast'
          });
          this.localPlayer.state = "cast";
          return;
        }
        if (this.keysDown[Constant.KEYCODE_RIGHT] && this.keysDown[Constant.KEYCODE_UP]) {
          this.socket.emit("update", {
            id: this.id,
            action: 'run',
            dir: 'ur'
          });
          return;
        }
        if (this.keysDown[Constant.KEYCODE_LEFT] && this.keysDown[Constant.KEYCODE_UP]) {
          this.socket.emit("update", {
            id: this.id,
            action: 'run',
            dir: 'ul'
          });
          return;
        }
        if (this.keysDown[Constant.KEYCODE_RIGHT] && this.keysDown[Constant.KEYCODE_DOWN]) {
          this.socket.emit("update", {
            id: this.id,
            action: 'run',
            dir: 'dr'
          });
          return;
        }
        if (this.keysDown[Constant.KEYCODE_LEFT] && this.keysDown[Constant.KEYCODE_DOWN]) {
          this.socket.emit("update", {
            id: this.id,
            action: 'run',
            dir: 'dl'
          });
          return;
        }
        if (this.keysDown[Constant.KEYCODE_RIGHT]) {
          this.socket.emit("update", {
            id: this.id,
            action: 'run',
            dir: 'right'
          });
          return;
        }
        if (this.keysDown[Constant.KEYCODE_LEFT]) {
          this.socket.emit("update", {
            id: this.id,
            action: 'run',
            dir: 'left'
          });
          return;
        }
        if (this.keysDown[Constant.KEYCODE_UP]) {
          this.socket.emit("update", {
            id: this.id,
            action: 'run',
            dir: 'up'
          });
          return;
        }
        if (this.keysDown[Constant.KEYCODE_DOWN]) {
          this.socket.emit("update", {
            id: this.id,
            action: 'run',
            dir: 'down'
          });
        }
      }
    };

    Game.prototype.onKeyDown = function(e) {
      return this.keysDown[e.keyCode] = true;
    };

    Game.prototype.onKeyUp = function(e) {
      return this.keysDown[e.keyCode] = false;
    };

    Game.prototype.is_outofBound = function(object) {
      var bound;
      bound = this.world.getBound();
      return object.x > bound['x2'] || object.x < 0 || object.y > bound['y2'] || object.y < 0;
    };

    Game.prototype.checkState = function(player) {
      var _ref;
      if (player === null) {
        return false;
      }
      if ((_ref = player.state) === 'collided' || _ref === 'disabled' || _ref === 'hurt' || _ref === 'attack' || _ref === "die") {
        return false;
      }
      return true;
    };

    Game.prototype.buildCharacter = function(object) {
      var character;
      character = new Character(object.id, object.name, object.type, object.x, object.y, this.world);
      character.build(object.spriteSheetInfo, object.magicSheetInfo);
      return character;
    };

    return Game;

  })();

}).call(this);
