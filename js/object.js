// Generated by CoffeeScript 1.7.1
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  window.object = (function() {
    function object(id, name, type, x, y, world) {
      this.id = id;
      this.name = name;
      this.type = type;
      this.x = x;
      this.y = y;
      this.world = world;
      this.moveStep = __bind(this.moveStep, this);
      this.hp;
      this.maxhp;
      this.spriteSheetInfo;
      this.SpriteSheet;
      this.sprite;
      this.init();
    }

    object.prototype.init = function() {
      this.mass = 1;
      this.speed = 0;
      this.originSpeed = 2;
      this.collisionHeight = 20;
      this.collisionWidth = 30;
      this.magicState = "ready";
      this.direction = "No";
      return this.state = "idle";
    };

    object.prototype.build = function(spriteSheetInfo) {
      if (!this.spriteSheetInfo) {
        this.spriteSheetInfo = spriteSheetInfo;
      }
      this.SpriteSheet = new createjs.SpriteSheet(this.spriteSheetInfo);
      this.sprite = new createjs.BitmapAnimation(this.SpriteSheet);
      this.sprite.x = this.x;
      this.sprite.y = this.y;
      if (this.direction === "left") {
        this.get().scaleX = -this.get().scaleX;
      }
      this.world.addObject(this);
      return this.sprite.gotoAndPlay("idle");
    };

    object.prototype.get = function() {
      return this.sprite;
    };

    object.prototype.counterDirection = function(direction) {
      switch (direction) {
        case "right":
          return "left";
          break;
        case "left":
          return "right";
          break;
        case "up":
          return "down";
          break;
        case "down":
          return "up";
          break;
        case "No":
          return "No";
      }
    };

    object.prototype.reverseDirection = function() {
      this.direction = this.counterDirection(this.direction);
      return console.log(this.name + ' reversed to ' + this.direction);
    };

    object.prototype.moveStep = function(direction) {
      var bound;
      bound = this.world.getBound();
      switch (direction) {
        case "left":
          if (this.direction !== "left") {
            this.direction = "left";
          }
          if (this.get().x - this.speed > bound['x1']) {
            this.get().x -= this.speed;
          } else {
            this.get().x += this.speed;
          }
          break;
        case "right":
          if (this.direction !== "right") {
            this.direction = "right";
          }
          if (this.get().x + this.speed < bound['x2']) {
            this.get().x += this.speed;
          } else {
            this.get().x -= this.speed;
          }
          break;
        case "down":
          this.direction = "down";
          if (this.get().y + this.speed < bound['y2']) {
            this.get().y += this.speed;
          } else {
            this.get().y -= this.speed;
          }
          break;
        case "up":
          this.direction = "up";
          if (this.get().y - this.speed > bound['y1']) {
            this.get().y -= this.speed;
          } else {
            this.get().y += this.speed;
          }
      }
      return this.updateCoords();
    };

    object.prototype.moveTo = function(x, y) {
      var bound;
      bound = this.world.getBound();
      if (x > bound['x1'] && x < bound['x2'] && y > bound['y1'] && y < bound['y2']) {
        this.get().x = x;
        this.get().y = y;
        return this.updateCoords();
      } else {
        return console.log('invalid coordinates: (' + x + ',' + y + ')');
      }
    };

    object.prototype.getRect = function() {
      var x1, x2, y1, y2;
      x1 = this.get().getBounds().x + this.get().x;
      y1 = this.get().getBounds().y + this.get().y;
      x2 = this.get().getBounds().x + this.get().x + this.get().getBounds().width;
      y2 = this.get().getBounds().y + this.get().y + this.get().getBounds().height;
      return {
        "x1": x1,
        "x2": x2,
        "y1": y1,
        "y2": y2
      };
    };

    object.prototype.getCollisionRect = function() {
      var x1, x2, y1, y2;
      x1 = this.get().getBounds().x + this.get().x + this.collisionWidth;
      y1 = this.get().getBounds().y + this.get().y + this.collisionHeight;
      x2 = this.get().getBounds().x + this.get().x + this.get().getBounds().width - this.collisionWidth;
      y2 = this.get().getBounds().y + this.get().y + this.get().getBounds().height - this.collisionHeight;
      return {
        "x1": x1,
        "x2": x2,
        "y1": y1,
        "y2": y2
      };
    };

    object.prototype.gotHit = function(direction) {
      if (this.sprite.currentAnimation !== "hurt") {
        this.sprite.gotoAndPlay("hurt");
      }
      return this.state = "hurt";
    };

    object.prototype.run = function(direction) {
      if (this.sprite.currentAnimation !== "run") {
        this.sprite.gotoAndPlay("run");
      }
      this.direction = direction;
      return this.state = "run";
    };

    object.prototype.die = function() {
      if (this.state !== "die") {
        if (this.sprite.currentAnimation !== "die") {
          this.sprite.gotoAndPlay("die");
          return this.state = "die";
        }
      }
    };

    object.prototype.idle = function() {
      this.speed = 0;
      this.direction = "No";
      this.state = "idle";
      if (this.sprite.currentAnimation !== "idle") {
        return this.sprite.gotoAndPlay("idle");
      }
    };

    object.prototype.update = function(object) {
      switch (object.state) {
        case 'die':
          return this.die();
        case 'hurt':
          this.gotHit(object.faceDirection);
          return this.hp = object.hp;
        case 'run':
          this.changeFaceDirection(object.faceDirection);
          this.run(object.direction);
          this.get().x = object.x;
          return this.get().y = object.y;
        case 'collided':
          this.get().x = object.x;
          return this.get().y = object.y;
        case 'idle':
          return this.idle();
      }
    };

    return object;

  })();

}).call(this);
