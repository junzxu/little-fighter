// Generated by CoffeeScript 1.7.1
(function() {
  var Game, Magic, Player, Robot, UUID, World, util;

  util = require("util");

  Player = require("./character.js");

  Robot = require("./robot.js");

  World = require("./world.js");

  Magic = require("./magic.js");

  UUID = require('node-uuid');

  Game = (function() {
    function Game(id, io) {
      this.id = id;
      this.io = io;
      this.room = this.id;
      this.player_count = 0;
      this.min_player = 1;
      this.max_player = 4;
      this.state = "preparing";
      this.init();
    }

    Game.prototype.init = function() {
      var id, robot;
      this.world = new World("basic");
      this.objects = [];
      this.players = [];
      id = UUID();
      robot = new Robot(id, "Julian", "robot", 500, 200, this.world);
      return this.addPlayer(robot);
    };

    Game.prototype.start = function() {
      this.state = "start";
      return this.updateID = setInterval(this.updateState.bind(this), 16);
    };

    Game.prototype.end = function() {
      clearInterval(this.updateID);
      this.world = null;
      this.objects = [];
      return this.players = [];
    };

    Game.prototype.handleInput = function(data) {
      var player;
      player = this.getPlayerById(data.id);
      if (player !== null) {
        switch (data.action) {
          case "run":
            return this.onPlayerMove(player, data.dir);
          case "attack":
            return this.onPlayerAttack(player);
          case "cast":
            return this.onPlayerCast(player);
          case "keyup":
            if (player.state = "run") {
              return player.idle();
            }
            break;
          case "animationend":
            return this.onAnimationend(player);
        }
      }
    };

    Game.prototype.onPlayerMove = function(player, dir) {
      return player.move(dir);
    };

    Game.prototype.onPlayerAttack = function(player) {
      var dir, distance, target, _ref;
      if (player.attack()) {
        _ref = this.getNearestCharacter(player), target = _ref[0], distance = _ref[1];
        if (target !== null && distance < player.attackRange && player.faceDirection === player.realtiveDirection(target)) {
          dir = player.faceDirection;
          return target.gotHit(player.damage, player.counterDirection(dir));
        }
      }
    };

    Game.prototype.onPlayerCast = function(player) {
      var bound, id, m, width, x;
      if (player.cast()) {
        bound = player.getRect();
        width = bound.x2 - bound.x1;
        id = UUID();
        x = player.faceDirection === 'right' ? bound.x2 : bound.x1;
        m = new Magic(id, 'blue', x, player.y, this.world, player.id, player.faceDirection);
        return this.addObject(m);
      }
    };

    Game.prototype.onAnimationend = function(player) {
      return player.idle();
    };

    Game.prototype.onRemovePlayer = function(client_id) {
      var player;
      player = this.getPlayerById(client_id);
      if (this.removePlayer(player)) {
        this.io.sockets["in"](this.room).emit("player disconnect", {
          "id": client_id,
          "player": player
        });
        return true;
      }
      return false;
    };

    Game.prototype.onNewPlayer = function(client) {
      var bound, id, player, x, y;
      if (this.player_count >= this.max_player) {
        return null;
      }
      bound = this.world.getBound();
      x = 100;
      y = 200;
      id = client.userid;
      player = new Player(id, "firzen", "player", x, y, this.world);
      this.addPlayer(player, this.player_count);
      this.io.sockets["in"](this.room).emit("new player", {
        "id": id,
        "player": player
      });
      return player;
    };

    Game.prototype.handle_collision = function() {
      var object, _i, _len, _ref, _results;
      _ref = this.objects;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        object = _ref[_i];
        if (object.state !== 'collided') {
          _results.push(this.detectCollision(object));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Game.prototype.detectCollision = function(object) {
      var dir, otherObject, rect1, rect2, _i, _len, _ref, _results;
      rect1 = object.getCollisionRect();
      _ref = this.objects;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        otherObject = _ref[_i];
        if (object.id === otherObject.id || otherObject.state === "die") {
          continue;
        }
        rect2 = otherObject.getCollisionRect();
        if (!((rect2.x2 < rect1.x1) || (rect2.x1 > rect1.x2) || (rect2.y1 > rect1.y2) || (rect2.y2 < rect1.y1))) {
          dir = object.counterDirection(object.direction);
          _results.push(object.collisionHandler(otherObject, dir));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Game.prototype.updateState = function() {
      var len, object;
      len = this.objects.length - 1;
      while (len >= 0) {
        object = this.objects[len];
        len -= 1;
        if (this.is_outofBound(object)) {
          this.removeObject(object);
        }
        if (object.type === 'robot') {
          object.update(this);
        }
        switch (object.state) {
          case "collided":
            object.moveStep();
            break;
          case "run":
            object.moveStep();
            this.detectCollision(object);
            break;
          case "removed":
            this.removeObject(object);
        }
      }
      return this.io.sockets["in"](this.room).emit("update", {
        objects: this.objects
      });
    };

    Game.prototype.addPlayer = function(player, number) {
      if (number == null) {
        number = 0;
      }
      if (this.player_count < this.max_player) {
        this.objects.push(player);
        this.players.push(player);
        if (player.number == null) {
          player.number = number;
        }
        if (player.type === "player") {
          this.player_count += 1;
        }
        if (this.player_count >= this.min_player) {
          this.start();
        }
        return true;
      }
      return false;
    };

    Game.prototype.addObject = function(object) {
      return this.objects.push(object);
    };

    Game.prototype.removeObject = function(target) {
      var index, object, _i, _len, _ref;
      _ref = this.objects;
      for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
        object = _ref[index];
        if (object.id === target.id) {
          this.objects.splice(index, 1);
          this.io.sockets["in"](this.room).emit("remove", {
            object: target
          });
          return true;
        }
      }
      return false;
    };

    Game.prototype.removePlayer = function(target) {
      var index, player, _i, _len, _ref;
      if (target === null) {
        return false;
      }
      this.removeObject(target);
      _ref = this.players;
      for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
        player = _ref[index];
        if (player.id === target.id) {
          this.players.splice(index, 1);
          this.player_count -= 1;
          return true;
        }
      }
      return false;
    };

    Game.prototype.getPlayers = function() {
      return this.players;
    };

    Game.prototype.getObjects = function() {
      return this.objects;
    };

    Game.prototype.getPlayerById = function(id) {
      var player, _i, _len, _ref;
      _ref = this.players;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        player = _ref[_i];
        if (player.id === id) {
          return player;
        }
      }
      return null;
    };

    Game.prototype.getNearestCharacter = function(character) {
      var d, distance, index, player, target, _i, _len, _ref;
      distance = Infinity;
      index = 0;
      target = null;
      _ref = this.players;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        player = _ref[_i];
        if (player.id === character.id) {
          continue;
        }
        d = character.distanceTo(player);
        if (d < distance) {
          distance = d;
          target = player;
        }
      }
      return [target, distance];
    };

    Game.prototype.getBound = function() {
      return {
        "x1": 0,
        "x2": this.world.width,
        "y1": 0,
        "y2": this.world.height
      };
    };

    Game.prototype.is_outofBound = function(object) {
      var bound;
      bound = this.world.getBound();
      return object.x - object.width > bound['x2'] || object.x + object.width < 0 || object.y - object.height > bound['y2'] || object.y + object.height < 0;
    };

    return Game;

  })();

  module.exports = Game;

}).call(this);
