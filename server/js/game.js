// Generated by CoffeeScript 1.7.1
(function() {
  var Game, Item, Magic, Player, Robot, UUID, World, util;

  util = require("util");

  Player = require("./character.js");

  Robot = require("./robot.js");

  World = require("./world.js");

  Magic = require("./magic.js");

  Item = require("./item.js");

  UUID = require('node-uuid');

  Game = (function() {
    function Game(id, io) {
      this.id = id;
      this.io = io;
      this.room = this.id;
      this.player_count = 0;
      this.min_player = 1;
      this.max_player = 4;
      this.active = false;
      this.init();
    }

    Game.prototype.init = function() {
      var object, robot, robot_id, _i, _len, _ref;
      this.world = new World("basic");
      this.objects = [];
      this.players = [];
      _ref = this.world.objects;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        object = _ref[_i];
        this.objects.push(object);
      }
      robot_id = UUID();
      this.bound = this.world.getBound();
      robot = new Robot(robot_id, "julian", "robot", 500, 200, this.bound);
      return this.addPlayer(robot);
    };

    Game.prototype.start = function() {
      this.active = true;
      this.updateID = setInterval(this.updateState.bind(this), 16);
      this.generateHealth = setInterval((function() {
        var health, item_id, x, y;
        item_id = UUID();
        x = this.bound.x1 + Math.floor(Math.random() * (this.bound.x2 - this.bound.x1 - 50));
        y = this.bound.y1 + Math.floor(Math.random() * (this.bound.y2 - this.bound.y1 - 50));
        health = new Item(item_id, "health", x, y, this.bound);
        return this.addObject(health);
      }).bind(this), 10000);
      return this.io.sockets["in"](this.room).emit("start", {
        "gameid": this.id
      });
    };

    Game.prototype.end = function() {
      clearInterval(this.updateID);
      clearInterval(this.generateCoin);
      this.world = null;
      this.objects = [];
      return this.players = [];
    };

    Game.prototype.handleInput = function(data) {
      var player;
      player = this.getPlayerById(data.id);
      if (player !== null) {
        switch (data.action) {
          case "run":
            return this.onPlayerMove(player, data.dir);
          case "attack":
            return this.onPlayerAttack(player);
          case "cast":
            return this.onPlayerCast(player);
          case "keyup":
            if (player.state === "run") {
              return player.idle();
            }
            break;
          case "animationend":
            return this.onAnimationend(player);
        }
      }
    };

    Game.prototype.onPlayerMove = function(player, dir) {
      return player.move(dir);
    };

    Game.prototype.onPlayerAttack = function(player) {
      var dir, distance, target, _ref;
      if (player.attack()) {
        _ref = this.getNearestObject(player), target = _ref[0], distance = _ref[1];
        if (target !== null && distance < player.attackRange && player.faceDirection === player.realtiveDirection(target)) {
          dir = player.faceDirection;
          return target.gotHit(player.damage, player.counterDirection(dir));
        }
      }
    };

    Game.prototype.onPlayerCast = function(player) {
      var bound, id, m, width, x;
      if (player.cast()) {
        if (player.type === "robot") {
          bound = player.getRect();
          width = bound.x2 - bound.x1;
          id = UUID();
          x = player.faceDirection === 'right' ? bound.x2 : bound.x1;
          m = new Magic(id, player.magicInfo, x, player.y, player.id, player.faceDirection);
          return setTimeout(((function(_this) {
            return function() {
              if (player.checkState()) {
                return _this.addObject(m);
              }
            };
          })(this)).bind(this), player.animationTime("cast"));
        }
      }
    };

    Game.prototype.onAnimationend = function(player) {
      var dir, distance, id, target, _ref;
      if (player.state === "cast") {
        id = UUID();
        player.magic(this, player, id);
      }
      if (player.state === "attack") {
        _ref = this.getNearestObject(player), target = _ref[0], distance = _ref[1];
        if (target !== null && distance < player.attackRange && player.faceDirection === player.realtiveDirection(target)) {
          dir = player.faceDirection;
          target.gotHit(2 * player.damage, player.counterDirection(dir));
        }
      }
      return player.idle();
    };

    Game.prototype.onRemovePlayer = function(client_id) {
      var player;
      player = this.getPlayerById(client_id);
      if (this.removePlayer(player)) {
        this.io.sockets["in"](this.room).emit("player disconnect", {
          "id": client_id,
          "player": player
        });
        return true;
      }
      return false;
    };

    Game.prototype.onNewPlayer = function(client) {
      var bound, id, magic_schema, player, x, y;
      if (this.player_count >= this.max_player) {
        return null;
      }
      bound = this.world.getBound();
      x = 100;
      y = 200;
      id = client.userid;
      player = new Player(id, "firzen", "player", x, y, this.world.getBound());
      player.username = client.username;
      magic_schema = require("./magics/wave.js");
      player.magicSheetInfo = magic_schema.magicSheetInfo;
      player.magicInfo = magic_schema.info;
      player.magic = magic_schema.magic;
      player.cd = magic_schema.info.cd;
      this.addPlayer(player, this.player_count);
      this.io.sockets["in"](this.room).emit("new player", {
        "id": id,
        "player": player
      });
      return player;
    };

    Game.prototype.handle_collision = function() {
      var object, _i, _len, _ref, _results;
      _ref = this.objects;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        object = _ref[_i];
        if (object.state !== 'collided') {
          _results.push(this.detectCollision(object));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Game.prototype.detectCollision = function(object) {
      var dir, otherObject, rect1, rect2, _i, _len, _ref, _ref1, _results;
      rect1 = object.getCollisionRect();
      _ref = this.objects;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        otherObject = _ref[_i];
        if (object.id === otherObject.id || otherObject.state === "die") {
          continue;
        }
        if ((object.type === (_ref1 = otherObject.type) && _ref1 === "magic")) {
          continue;
        }
        if (object.id === otherObject.characterID || object.characterID === otherObject.id) {
          continue;
        }
        rect2 = otherObject.getCollisionRect();
        if (!((rect2.x2 < rect1.x1) || (rect2.x1 > rect1.x2) || (rect2.y1 > rect1.y2) || (rect2.y2 < rect1.y1))) {
          dir = object.counterDirection(object.direction);
          _results.push(object.collisionHandler(otherObject, dir));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Game.prototype.updateState = function() {
      var len, object, object_status;
      object_status = [];
      len = this.objects.length - 1;
      while (len >= 0) {
        object = this.objects[len];
        len -= 1;
        if (this.is_outofBound(object)) {
          this.removeObject(object);
          continue;
        }
        if (object.type === 'robot') {
          object.update(this);
        }
        switch (object.state) {
          case "collided":
            object.moveStep();
            break;
          case "run":
            object.moveStep();
            this.detectCollision(object);
            break;
          case "cast":
            this.onPlayerCast(object);
            break;
          case "removed":
            this.removeObject(object);
            continue;
        }
        object_status.push(object.getStatus());
      }
      return this.io.sockets["in"](this.room).emit("update", {
        objects: object_status
      });
    };

    Game.prototype.addPlayer = function(player, number) {
      if (number == null) {
        number = 0;
      }
      if (this.player_count < this.max_player) {
        this.objects.push(player);
        this.players.push(player);
        if (player.number == null) {
          player.number = number;
        }
        if (player.type === "player") {
          this.player_count += 1;
        }
        if (this.player_count >= this.min_player && this.active === false) {
          this.start();
        }
        return true;
      }
      return false;
    };

    Game.prototype.addObject = function(object) {
      this.objects.push(object);
      if (object.type === "item") {
        return this.io.sockets["in"](this.room).emit("new object", {
          "object": object
        });
      }
    };

    Game.prototype.addMagic = function(id, info, x, y, characterID, faceDirection) {
      var m;
      m = new Magic(id, info, x, y, characterID, faceDirection);
      return this.addObject(m);
    };

    Game.prototype.removeObject = function(target) {
      var index, object, _i, _len, _ref;
      _ref = this.objects;
      for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
        object = _ref[index];
        if (object.id === target.id) {
          this.objects.splice(index, 1);
          this.io.sockets["in"](this.room).emit("remove", {
            "object": target
          });
          return true;
        }
      }
      return false;
    };

    Game.prototype.removePlayer = function(target) {
      var index, player, _i, _len, _ref;
      if (target === null) {
        return false;
      }
      this.removeObject(target);
      _ref = this.players;
      for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
        player = _ref[index];
        if (player.id === target.id) {
          this.players.splice(index, 1);
          this.player_count -= 1;
          return true;
        }
      }
      return false;
    };

    Game.prototype.getPlayers = function() {
      return this.players;
    };

    Game.prototype.getObjects = function() {
      return this.objects;
    };

    Game.prototype.getPlayerById = function(id) {
      var player, _i, _len, _ref;
      _ref = this.players;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        player = _ref[_i];
        if (player.id === id) {
          return player;
        }
      }
      return null;
    };

    Game.prototype.getNearestCharacter = function(character) {
      var d, distance, index, player, target, _i, _len, _ref;
      distance = Infinity;
      index = 0;
      target = null;
      _ref = this.players;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        player = _ref[_i];
        if (player.id === character.id || player.animation === "invisible") {
          continue;
        }
        d = character.distanceTo(player);
        if (d < distance) {
          distance = d;
          target = player;
        }
      }
      return [target, distance];
    };

    Game.prototype.getNearestObject = function(character) {
      var d, distance, index, object, target, _i, _len, _ref;
      distance = Infinity;
      index = 0;
      target = null;
      _ref = this.objects;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        object = _ref[_i];
        if (object.id === character.id) {
          continue;
        }
        d = character.distanceTo(object);
        if (d < distance) {
          distance = d;
          target = object;
        }
      }
      return [target, distance];
    };

    Game.prototype.getBound = function() {
      return {
        "x1": 0,
        "x2": this.world.width,
        "y1": 0,
        "y2": this.world.height
      };
    };

    Game.prototype.is_outofBound = function(object) {
      var bound;
      bound = this.world.getBound();
      return object.x - object.width > bound['x2'] || object.x + object.width < 0 || object.y - object.height > bound['y2'] || object.y + object.height < 0;
    };

    return Game;

  })();

  module.exports = Game;

}).call(this);
